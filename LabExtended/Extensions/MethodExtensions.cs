using System.Reflection;
using System.Text.RegularExpressions;
using System.Runtime.CompilerServices;

namespace LabExtended.Extensions;
/// <summary>
/// Extensions targeting reflection methods.
/// </summary>
public static class MethodExtensions
{
    /// <summary>
    /// Binding flags of public / private and instance / static members.
    /// </summary>
    public const BindingFlags Flags = TypeExtensions.Flags;

    /// <summary>
    /// Gets a regular expression that matches the pattern used for local variable names generated by the compiler.
    /// </summary>
    /// <remarks>This regular expression is intended for identifying compiler-generated local variable names
    /// that follow the pattern "{name}g__method|number_number". It is compiled for improved performance when used
    /// repeatedly.</remarks>
    public static Regex LocalRegex { get; } = new("^<(\\w+)>g__(\\w+)\\|\\d+_\\d+", RegexOptions.Compiled);

    private static readonly Dictionary<MethodBase, MethodInfo[]> _localMethods = new();
    private static readonly Dictionary<MethodBase, ParameterInfo[]> _parameters = new();

    /// <summary>
    /// Determines whether the specified method is a compiler-generated local function associated with the given parent
    /// method.
    /// </summary>
    /// <remarks>This method checks for compiler-generated local functions by matching the method name pattern
    /// and verifying the presence of the CompilerGeneratedAttribute. It is useful for scenarios such as code analysis
    /// or reflection where distinguishing local functions from other methods is necessary.</remarks>
    /// <param name="method">The method to evaluate. This should be a method that may represent a local function. Cannot be null.</param>
    /// <param name="parentMethod">The parent method to compare against. The method is considered local if it is compiler-generated and associated
    /// with this parent. Cannot be null.</param>
    /// <returns>true if the specified method is a compiler-generated local function of the given parent method; otherwise,
    /// false.</returns>
    public static bool IsLocalMethod(this MethodBase method, MethodBase parentMethod)
    {
        if (method == null
            || parentMethod == null)
            return false;

        var match = LocalRegex.Match(method.Name);

        if (match == null)
            return false;

        if (match.Groups[1].Value != parentMethod.Name)
            return false;

        if (!method.HasAttribute<CompilerGeneratedAttribute>())
            return false;

        return true;
    }

    /// <summary>
    /// Determines whether the specified method represents a local function with the given name defined within a
    /// specified surrounding method.
    /// </summary>
    /// <remarks>This method is useful for identifying compiler-generated methods that correspond to local
    /// functions in C# source code. The check is based on the naming convention used by the C# compiler for local
    /// functions in generated metadata.</remarks>
    /// <param name="localMethod">The <see cref="MethodInfo"/> instance to examine. Represents the method to check for local function
    /// characteristics.</param>
    /// <param name="surroundingMethodName">The name of the method in which the local function is expected to be defined. Cannot be null or empty.</param>
    /// <param name="localMethodName">The name of the local function to match. Cannot be null or empty.</param>
    /// <returns>true if the specified method is a local function with the given name defined within the specified surrounding
    /// method; otherwise, false.</returns>
    public static bool IsLocalMethod(this MethodInfo localMethod, string surroundingMethodName, string localMethodName)
        => Regex.IsMatch(localMethod.Name, $@"^<{surroundingMethodName}>g__{localMethodName}\|\d+(_\d+)?");

    /// <summary>
    /// Retrieves the MethodInfo for a local function defined within a specified method of the given type, using the
    /// local function's name and its surrounding method's name.
    /// </summary>
    /// <remarks>This method searches for compiler-generated representations of local functions within the
    /// specified type and its compiler-generated nested types. Local functions are not directly accessible via standard
    /// reflection APIs; this method provides a way to locate them by name for advanced scenarios such as code analysis
    /// or dynamic invocation.</remarks>
    /// <param name="type">The type to search for the local function. Must not be null.</param>
    /// <param name="surroundingMethodName">The name of the method that contains the local function.</param>
    /// <param name="localMethodName">The name of the local function to locate.</param>
    /// <returns>A MethodInfo representing the local function if found; otherwise, null.</returns>
    public static MethodInfo? GetLocalMethod(this Type type, string surroundingMethodName, string localMethodName)
    {
        var method = type.GetMethods(BindingFlags.NonPublic | BindingFlags.Static)
                .FirstOrDefault(m => m.GetCustomAttribute<CompilerGeneratedAttribute>() != null
                     && m.IsLocalMethod(surroundingMethodName, localMethodName));

        if (method is not null) 
            return method;

        var nestedTypes = type.GetNestedTypes(BindingFlags.NonPublic)
                           .Where(t => t.GetCustomAttribute<CompilerGeneratedAttribute>() != null);

        foreach (var nested in nestedTypes)
        {
            method = nested.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance)
                            .FirstOrDefault(m => m.IsLocalMethod(surroundingMethodName, localMethodName));

            if (method is not null)
                return method;
        }

        return null;
    }

    /// <summary>
    /// Retrieves all local methods associated with the specified method, including compiler-generated local functions
    /// and their implementations.
    /// </summary>
    /// <remarks>Local methods include both static and instance methods that are compiler-generated as local
    /// functions within the specified method. The result is cached for subsequent calls with the same method.</remarks>
    /// <param name="method">The method for which to retrieve local methods. Cannot be null.</param>
    /// <returns>An array of <see cref="MethodInfo"/> objects representing all local methods related to the specified method. The
    /// array is empty if no local methods are found.</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="method"/> is null.</exception>
    /// <exception cref="Exception">Thrown if the specified method does not have a declaring type.</exception>
    public static MethodInfo[] GetAllLocalMethods(this MethodBase method)
    {
        if (method == null)
            throw new ArgumentNullException(nameof(method));

        if (_localMethods.TryGetValue(method, out var array))
            return array;

        var type = method.DeclaringType ?? method.ReflectedType;

        if (type == null)
            throw new Exception($"Method {method} does not have a declaring type");

        var locals = new List<MethodInfo>();

        foreach (var localMethod in type
             .GetMethods(BindingFlags.NonPublic | BindingFlags.Static)
             .Where(x => x.IsLocalMethod(method))
                .Union(type
                        .GetNestedTypes(BindingFlags.NonPublic)
                        .Where(t => t.GetCustomAttribute<CompilerGeneratedAttribute>() != null)
                        .SelectMany(t => t.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance)
                        .Where(x => x.IsLocalMethod(method)))))
            locals.Add(localMethod);

        array = locals.ToArray();

        locals.Clear();

        _localMethods.Add(method, array);
        return array;
    }

    /// <summary>
    /// Gets all (cached) parameters in a method's overload.
    /// </summary>
    public static ParameterInfo[] GetAllParameters(this MethodBase method)
    {
        if (_parameters.TryGetValue(method, out var parameters))
            return parameters;

        return _parameters[method] = method.GetParameters();
    }
}